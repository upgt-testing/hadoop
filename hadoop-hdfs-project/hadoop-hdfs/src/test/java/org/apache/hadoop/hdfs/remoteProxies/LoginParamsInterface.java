package org.apache.hadoop.hdfs.remoteProxies;

public interface LoginParamsInterface {
//    void replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V> arg0);
    boolean containsMapping(java.lang.Object arg0, java.lang.Object arg1);
//    V computeIfAbsent(K arg0, java.util.function.Function<? super K, ? extends V> arg1);
    java.lang.Object maskNull(java.lang.Object arg0);
//    java.lang.String put(org.apache.hadoop.security.UserGroupInformation.LoginParam arg0, java.lang.String arg1);
//    V merge(K arg0, V arg1, java.util.function.BiFunction<? super V, ? super V, ? extends V> arg2);
    int entryHashCode(int arg0);
//    V putIfAbsent(K arg0, V arg1);
    void clear();
//    void forEach(java.util.function.BiConsumer<? super K, ? super V> arg0);
    boolean equals(java.util.EnumMap<?, ?> arg0);
    <K, V> java.util.Map<K, V> of(K arg0, V arg1, K arg2, V arg3, K arg4, V arg5, K arg6, V arg7);
    int hashCode();
    boolean containsValue(java.lang.Object arg0);
//    void putAll(java.util.Map<? extends K, ? extends V> arg0);
//    V getOrDefault(java.lang.Object arg0, V arg1);
//    void typeCheck(K arg0);
    <K, V> java.util.Map<K, V> of(K arg0, V arg1, K arg2, V arg3, K arg4, V arg5, K arg6, V arg7, K arg8, V arg9);
    <K, V> java.util.Map<K, V> of(K arg0, V arg1, K arg2, V arg3, K arg4, V arg5, K arg6, V arg7, K arg8, V arg9, K arg10, V arg11, K arg12, V arg13, K arg14, V arg15);
    boolean removeMapping(java.lang.Object arg0, java.lang.Object arg1);
//    java.lang.Object clone() throws java.lang.CloneNotSupportedException;
    void readObject(java.io.ObjectInputStream arg0) throws java.io.IOException, java.lang.ClassNotFoundException;
//    V unmaskNull(java.lang.Object arg0);
//    V remove(java.lang.Object arg0);
//    V get(java.lang.Object arg0);
//    java.util.Set<java.util.Map.Entry<K, V>> entrySet();
//    V computeIfPresent(K arg0, java.util.function.BiFunction<? super K, ? super V, ? extends V> arg1);
//    V put(K arg0, V arg1);
    <K, V> java.util.Map<K, V> of(K arg0, V arg1, K arg2, V arg3, K arg4, V arg5, K arg6, V arg7, K arg8, V arg9, K arg10, V arg11, K arg12, V arg13, K arg14, V arg15, K arg16, V arg17, K arg18, V arg19);
    <K> K[] getKeyUniverse(java.lang.Class<K> arg0);
    int size();
    boolean isEmpty();
    <K, V> java.util.Map<K, V> of(K arg0, V arg1);
    <K, V> java.util.Map<K, V> of(K arg0, V arg1, K arg2, V arg3, K arg4, V arg5, K arg6, V arg7, K arg8, V arg9, K arg10, V arg11, K arg12, V arg13, K arg14, V arg15, K arg16, V arg17);
    boolean isValidKey(java.lang.Object arg0);
    boolean eq(java.lang.Object arg0, java.lang.Object arg1);
    boolean equals(java.lang.Object arg0);
    <K, V> java.util.Map<K, V> of(K arg0, V arg1, K arg2, V arg3, K arg4, V arg5, K arg6, V arg7, K arg8, V arg9, K arg10, V arg11, K arg12, V arg13);
//    java.util.Collection<V> values();
    boolean containsKey(java.lang.Object arg0);
    <K, V> java.util.Map<K, V> copyOf(java.util.Map<? extends K, ? extends V> arg0);
//    V compute(K arg0, java.util.function.BiFunction<? super K, ? super V, ? extends V> arg1);
    void writeObject(java.io.ObjectOutputStream arg0) throws java.io.IOException;
    <K, V> java.util.Map<K, V> of(K arg0, V arg1, K arg2, V arg3, K arg4, V arg5, K arg6, V arg7, K arg8, V arg9, K arg10, V arg11);
    <K, V> java.util.Map.Entry<K, V> entry(K arg0, V arg1);
//    java.util.EnumMap<K, V> clone();
//    java.util.Set<K> keySet();
    <K, V> java.util.Map<K, V> of(K arg0, V arg1, K arg2, V arg3);
    <K, V> java.util.Map<K, V> of(K arg0, V arg1, K arg2, V arg3, K arg4, V arg5);
    <K, V> java.util.Map<K, V> of();
    java.lang.String toString();
//    boolean replace(K arg0, V arg1, V arg2);
    LoginParamsInterface getDefaults();
    boolean remove(java.lang.Object arg0, java.lang.Object arg1);
    <K, V> java.util.Map<K, V> ofEntries(java.util.Map.Entry<? extends K, ? extends V>... arg0);
//    V replace(K arg0, V arg1);
}