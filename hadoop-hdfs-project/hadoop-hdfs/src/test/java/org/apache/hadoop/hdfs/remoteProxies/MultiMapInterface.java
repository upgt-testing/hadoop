package org.apache.hadoop.hdfs.remoteProxies;

public interface MultiMapInterface<V> {
//    V putIfAbsent(K arg0, V arg1);
    java.util.List<V> getValues(java.lang.String arg0);
//    java.util.List<V> put(java.lang.String arg0, V arg1);
//    V put(K arg0, V arg1);
//    void forEach(java.util.function.BiConsumer<? super K, ? super V> arg0);
    int hashCode();
    <K, V> java.util.Map<K, V> ofEntries(java.util.Map.Entry<? extends K, ? extends V>... arg0);
    <K, V> java.util.Map<K, V> of(K arg0, V arg1, K arg2, V arg3, K arg4, V arg5, K arg6, V arg7, K arg8, V arg9, K arg10, V arg11, K arg12, V arg13);
    java.util.List<V> putValues(java.lang.String arg0, V... arg1);
    java.util.Collection<V> values();
//    boolean removeEldestEntry(java.util.Map.Entry<K, V> arg0);
//    void replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V> arg0);
    int capacity();
//    boolean replace(K arg0, V arg1, V arg2);
    V getValue(java.lang.String arg0, int arg1);
//    java.util.HashMap.Node<K, V> newNode(int arg0, K arg1, V arg2, java.util.HashMap.Node<K, V> arg3);
//    java.util.HashMap.TreeNode<K, V> newTreeNode(int arg0, K arg1, V arg2, java.util.HashMap.Node<K, V> arg3);
//    java.util.HashMap.TreeNode<K, V> replacementTreeNode(java.util.HashMap.Node<K, V> arg0, java.util.HashMap.Node<K, V> arg1);
//    java.util.Set<K> keySet();
    void afterNodeInsertion(boolean arg0);
    java.util.List<V> putValues(java.lang.String arg0, java.util.List<V> arg1);
    V get(java.lang.Object arg0);
//    V compute(K arg0, java.util.function.BiFunction<? super K, ? super V, ? extends V> arg1);
    <K, V> java.util.Map<K, V> of(K arg0, V arg1, K arg2, V arg3, K arg4, V arg5, K arg6, V arg7, K arg8, V arg9, K arg10, V arg11, K arg12, V arg13, K arg14, V arg15, K arg16, V arg17, K arg18, V arg19);
    java.lang.Object clone();
    float loadFactor();
    void readObject(java.io.ObjectInputStream arg0) throws java.io.IOException, java.lang.ClassNotFoundException;
    void clear();
    boolean eq(java.lang.Object arg0, java.lang.Object arg1);
    boolean equals(java.lang.Object arg0);
//    java.util.Set<java.util.Map.Entry<K, V>> entrySet();
//    void transferLinks(java.util.LinkedHashMap.Entry<K, V> arg0, java.util.LinkedHashMap.Entry<K, V> arg1);
    void writeObject(java.io.ObjectOutputStream arg0) throws java.io.IOException;
    boolean isEmpty();
    void internalWriteEntries(java.io.ObjectOutputStream arg0) throws java.io.IOException;
    V remove(java.lang.Object arg0);
    int compareComparables(java.lang.Class<?> arg0, java.lang.Object arg1, java.lang.Object arg2);
    <K, V> java.util.Map<K, V> of(K arg0, V arg1, K arg2, V arg3, K arg4, V arg5);
    boolean addAllValues(MultiMapInterface<V> arg0);
    java.lang.Class<?> comparableClassFor(java.lang.Object arg0);
//    void putAll(java.util.Map<? extends K, ? extends V> arg0);
    void add(java.lang.String arg0, V arg1);
//    java.util.HashMap.Node<K, V> replacementNode(java.util.HashMap.Node<K, V> arg0, java.util.HashMap.Node<K, V> arg1);
    <K, V> java.util.Map<K, V> of(K arg0, V arg1, K arg2, V arg3, K arg4, V arg5, K arg6, V arg7, K arg8, V arg9, K arg10, V arg11, K arg12, V arg13, K arg14, V arg15, K arg16, V arg17);
    boolean remove(java.lang.Object arg0, java.lang.Object arg1);
//    V putVal(int arg0, K arg1, V arg2, boolean arg3, boolean arg4);
    <K, V> java.util.Map<K, V> of(K arg0, V arg1, K arg2, V arg3, K arg4, V arg5, K arg6, V arg7, K arg8, V arg9, K arg10, V arg11, K arg12, V arg13, K arg14, V arg15);
    void addValues(java.lang.String arg0, java.util.List<V> arg1);
    V getOrDefault(java.lang.Object arg0, V arg1);
//    V merge(K arg0, V arg1, java.util.function.BiFunction<? super V, ? super V, ? extends V> arg2);
    <K, V> java.util.Map<K, V> of(K arg0, V arg1, K arg2, V arg3, K arg4, V arg5, K arg6, V arg7);
    boolean removeValue(java.lang.String arg0, V arg1);
//    void linkNodeLast(java.util.LinkedHashMap.Entry<K, V> arg0);
//    java.util.HashMap.Node<K, V> removeNode(int arg0, java.lang.Object arg1, java.lang.Object arg2, boolean arg3, boolean arg4);
//    void afterNodeAccess(java.util.HashMap.Node<K, V> arg0);
    <K, V> java.util.Map<K, V> of(K arg0, V arg1, K arg2, V arg3, K arg4, V arg5, K arg6, V arg7, K arg8, V arg9, K arg10, V arg11);
    int tableSizeFor(int arg0);
    <K, V> java.util.Map<K, V> of(K arg0, V arg1);
//    java.util.HashMap.Node<K, V> getNode(int arg0, java.lang.Object arg1);
    <K, V> java.util.Map<K, V> of();
    boolean containsValue(java.lang.Object arg0);
    java.lang.String getString(java.lang.String arg0);
//    void afterNodeRemoval(java.util.HashMap.Node<K, V> arg0);
//    V replace(K arg0, V arg1);
    void putAllValues(java.util.Map<java.lang.String, V> arg0);
    int hash(java.lang.Object arg0);
    java.lang.String toString();
    <K, V> java.util.Map<K, V> of(K arg0, V arg1, K arg2, V arg3);
    int size();
    <K, V> java.util.Map<K, V> of(K arg0, V arg1, K arg2, V arg3, K arg4, V arg5, K arg6, V arg7, K arg8, V arg9);
    boolean containsKey(java.lang.Object arg0);
//    void putMapEntries(java.util.Map<? extends K, ? extends V> arg0, boolean arg1);
    <K, V> java.util.Map<K, V> copyOf(java.util.Map<? extends K, ? extends V> arg0);
    java.util.Map<java.lang.String, java.lang.String[]> toStringArrayMap();
    void addValues(java.lang.String arg0, V[] arg1);
//    void treeifyBin(java.util.HashMap.Node<K, V>[] arg0, int arg1);
    <K, V> java.util.Map.Entry<K, V> entry(K arg0, V arg1);
    void reinitialize();
//    java.util.HashMap.Node<K, V>[] resize();
//    V computeIfPresent(K arg0, java.util.function.BiFunction<? super K, ? super V, ? extends V> arg1);
    boolean containsSimpleValue(V arg0);
//    V computeIfAbsent(K arg0, java.util.function.Function<? super K, ? extends V> arg1);
}