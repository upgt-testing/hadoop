package org.apache.hadoop.hdfs.remoteProxies;

public interface ImmutableMapInterface<K, V> {
    <K, V> ImmutableMapInterface<K, V> of(K arg0, V arg1, K arg2, V arg3, K arg4, V arg5);
    <K, V> ImmutableMapInterface<K, V> copyOf(java.util.Map<? extends K, ? extends V> arg0);
    ImmutableSetInterface<K> createKeySet();
    <K, V> java.util.Map<K, V> of(K arg0, V arg1, K arg2, V arg3, K arg4, V arg5, K arg6, V arg7, K arg8, V arg9, K arg10, V arg11, K arg12, V arg13, K arg14, V arg15, K arg16, V arg17, K arg18, V arg19);
    int size();
    boolean containsValue(java.lang.Object arg0);
    V put(K arg0, V arg1);
    boolean isHashCodeFast();
    <K, V> java.util.Map.Entry<K, V> entry(K arg0, V arg1);
    <K, V> java.util.Map<K, V> of(K arg0, V arg1, K arg2, V arg3, K arg4, V arg5, K arg6, V arg7, K arg8, V arg9, K arg10, V arg11, K arg12, V arg13);
    boolean equals(java.lang.Object arg0);
    <K, V> ImmutableMapInterface<K, V> of(K arg0, V arg1);
    <K, V> java.util.Map.Entry<K, V> entryOf(K arg0, V arg1);
    java.util.Set<K> keySet();
    void clear();
    <K, V> java.util.Map<K, V> ofEntries(java.util.Map.Entry<? extends K, ? extends V>... arg0);
    int hashCode();
    <K, V> java.util.Map<K, V> of(K arg0, V arg1, K arg2, V arg3, K arg4, V arg5, K arg6, V arg7, K arg8, V arg9);
    ImmutableSetMultimapInterface<K, V> asMultimap();
//    <K, V> ImmutableMapInterface<K, V> of(K arg0, V arg1, K arg2, V arg3, K arg4, V arg5, K arg6, V arg7, K arg8, V arg9);
//    ImmutableSetInterface<K> keySet();
    <K, V> ImmutableMapInterface<K, V> of(K arg0, V arg1, K arg2, V arg3, K arg4, V arg5, K arg6, V arg7);
    ImmutableCollectionInterface<V> createValues();
    V putIfAbsent(K arg0, V arg1);
    <K, V> java.util.Map<K, V> of(K arg0, V arg1, K arg2, V arg3);
    <K, V> java.util.Map<K, V> of(K arg0, V arg1, K arg2, V arg3, K arg4, V arg5, K arg6, V arg7, K arg8, V arg9, K arg10, V arg11, K arg12, V arg13, K arg14, V arg15, K arg16, V arg17);
    V remove(java.lang.Object arg0);
    void checkNoConflict(boolean arg0, java.lang.String arg1, java.util.Map.Entry<?, ?> arg2, java.util.Map.Entry<?, ?> arg3);
//    <K, V> ImmutableMapInterface<K, V> of(K arg0, V arg1, K arg2, V arg3);
//    <K, V> BuilderInterface<K, V> builder();
//    <K, V> java.util.Map<K, V> copyOf(java.util.Map<? extends K, ? extends V> arg0);
    V computeIfPresent(K arg0, java.util.function.BiFunction<? super K, ? super V, ? extends V> arg1);
    java.util.Set<java.util.Map.Entry<K, V>> entrySet();
    <K, V> java.util.Map<K, V> of();
//    <K, V> ImmutableMapInterface<K, V> copyOfEnumMap(java.util.EnumMap<K, ? extends V> arg0);
    void putAll(java.util.Map<? extends K, ? extends V> arg0);
    ImmutableSetInterface<java.util.Map.Entry<K, V>> createEntrySet();
    java.lang.String toString();
    boolean replace(K arg0, V arg1, V arg2);
    <K, V> java.util.Map<K, V> of(K arg0, V arg1, K arg2, V arg3, K arg4, V arg5, K arg6, V arg7, K arg8, V arg9, K arg10, V arg11);
    V get(java.lang.Object arg0);
//    <K, V> java.util.Map<K, V> of(K arg0, V arg1, K arg2, V arg3, K arg4, V arg5, K arg6, V arg7);
    java.util.Spliterator<K> keySpliterator();
    boolean isPartialView();
    UnmodifiableIteratorInterface<K> keyIterator();
    <T, K, V> java.util.stream.Collector<T, ?, org.apache.hadoop.thirdparty.com.google.common.collect.ImmutableMap<K, V>> toImmutableMap(java.util.function.Function<? super T, ? extends K> arg0, java.util.function.Function<? super T, ? extends V> arg1);
    ImmutableCollectionInterface<V> values();
    java.lang.Object writeReplace();
    <T, K, V> java.util.stream.Collector<T, ?, org.apache.hadoop.thirdparty.com.google.common.collect.ImmutableMap<K, V>> toImmutableMap(java.util.function.Function<? super T, ? extends K> arg0, java.util.function.Function<? super T, ? extends V> arg1, java.util.function.BinaryOperator<V> arg2);
    void forEach(java.util.function.BiConsumer<? super K, ? super V> arg0);
//    <K, V> java.util.Map<K, V> of(K arg0, V arg1, K arg2, V arg3, K arg4, V arg5);
    boolean containsKey(java.lang.Object arg0);
    V replace(K arg0, V arg1);
    java.lang.IllegalArgumentException conflictException(java.lang.String arg0, java.lang.Object arg1, java.lang.Object arg2);
//    <K, V> java.util.Map<K, V> of(K arg0, V arg1);
    <K, V> ImmutableMapInterface<K, V> copyOf(java.lang.Iterable<? extends java.util.Map.Entry<? extends K, ? extends V>> arg0);
    boolean remove(java.lang.Object arg0, java.lang.Object arg1);
//    <K, V> BuilderInterface<K, V> builderWithExpectedSize(int arg0);
    V merge(K arg0, V arg1, java.util.function.BiFunction<? super V, ? super V, ? extends V> arg2);
    <K, V> java.util.Map<K, V> of(K arg0, V arg1, K arg2, V arg3, K arg4, V arg5, K arg6, V arg7, K arg8, V arg9, K arg10, V arg11, K arg12, V arg13, K arg14, V arg15);
    boolean isEmpty();
    void replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V> arg0);
    V computeIfAbsent(K arg0, java.util.function.Function<? super K, ? extends V> arg1);
//    java.util.Collection<V> values();
    V compute(K arg0, java.util.function.BiFunction<? super K, ? super V, ? extends V> arg1);
//    ImmutableSetInterface<java.util.Map.Entry<K, V>> entrySet();
//    <K, V> ImmutableMapInterface<K, V> of();
    V getOrDefault(java.lang.Object arg0, V arg1);
}